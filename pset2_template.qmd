---
title: "30538 Problem Set 2: Parking Tickets"
author: "Yuliana Zhang"
date: "Wed Oct 9"

format: 
    pdf: 
        include-in-header: 
            text: | 
                \usepackage{fvextra} \DefineVerbatimEnvironment{Highlighting}{Verbatim}{breaklines,commandchars=\\\{\}} 
        
        include-before-body: 
            text: |
                \RecustomVerbatimEnvironment{verbatim}{Verbatim}{ showspaces = false, showtabs = false, breaksymbolleft={}, breaklines}
---


1. "This submission is my work alone and complies with the 30538 integrity
policy." Add your initials to indicate your agreement: \*\* YZ \*\*
2. "I have uploaded the names of anyone I worked with on the problem set **[here](https://docs.google.com/forms/d/1-zzHx762odGlpVWtgdIC55vqF-j3gqdAp6Pno1rIGK0/edit)**"  \*\* Yuanhao (Dale) Jin \*\* (1 point)
3. Late coins used this pset: \*\* 1\_*\* Late coins left after submission: \*\* 2 \_*\*
4. Knit your `ps2.qmd` to make `ps2.pdf`. 
    * The PDF should not be more than 25 pages. Use `head()` and re-size figures when appropriate. 
5. Push  `ps2.qmd` and `ps2.pdf` to your github repo. It is fine to use Github Desktop.
6. Submit `ps2.pdf` via Gradescope (8 points) 
7. Tag your submission in Gradescope

```{python}
import pandas as pd
import altair as alt
alt.renderers.enable("png")
import time

import warnings 
warnings.filterwarnings('ignore')

import os
# Local path
path = r'/Users/yuejiuzhang/Documents/Uchicago/PPHA30538/student30538/problem_sets/ps2/data/'

# File path
tickets = r'parking_tickets_one_percent.csv'
path_tickets = os.path.join(path, tickets)

# Load the parking tickets data
tickets_df = pd.read_csv(path_tickets)
```

## Data cleaning continued (15 points)

#### 1.  For each column, how many rows are NA? Write a function which returns a two column data frame where each row is a variable, the first column of the data frame is the name of each variable, and the second column of the data frame is the number of times that the column is NA. Test your function. Then, report the results applied to the parking tickets data frame. 

```{python}
# Build a function that returns a two column data frame
# ref from https://stackoverflow.com/questions/26266362/how-do-i-count-the-nan-values-in-a-column-in-pandas-dataframe
def return_na(dataframe):
    na_sum = {
        'Variable': dataframe.columns,
        'NA_Count': dataframe.isna().sum().values
    }
    na_df = pd.DataFrame(na_sum)
    return na_df

# Build a sample data frame form https://saturncloud.io/blog/how-to-count-nan-values-in-a-pandas-dataframe-column/
data = {
    'Name': ['John', 'Doe', 'Alice', 'Bob', 'Chris'],
    'Age': [25, 30, 22, 28, 35],
    'Salary': [50000, 60000, None, 75000, 90000],
    'Experience': [2, 5, 1, None, 10]
}
sample_df = pd.DataFrame(data)

# Test return_na function
test_na_df = return_na(sample_df)
display(test_na_df)

# Apply to the parking tickets data frame
tickets_na_summary = return_na(tickets_df)

# Report results
display(tickets_na_summary)
```

#### 2. Three variables are missing much more frequently than the others. Why? (Hint: look at some rows and read the )data dictionary written by ProPublica

Based on the results from (1), we can observe the top 3 missing variables are hearing_disposition (259899), notice_level (84068), and zipcode (54115). Besides, we can also observe that if the zipcode and notice_level is missing, the hearing_disposition is missing as well.

For hearing disposition, a missing value could indicate that no hearing was held. According to the articles, the increased cost of tickets resulted in a heavy financial burden for lower-income individuals, and thus, they chose to go bankrupt for these unpaid tickets and not attend hearings.

For notice_level, a missing value may indicate that the ticket did not escalate beyond the initial stage. The ProPublica articles also discuss how escalating fees disproportionately affect lower-income and minority communities, resulting in abandoned tickets that are never formally escalated to the next level. This might be the explanation for why this variable is frequently missing.

For zipcode field a missing value could be related to errors or inconsistencies in data entry, or the absence of complete address information when tickets are issued. 

#### 3. What was the old violation code and what is the new violation code?

```{python}
# Convert issue_date to time data
tickets_df['issue_date'] = pd.to_datetime(tickets_df['issue_date'])

# Use year to check the change over time
tickets_df['year'] = tickets_df['issue_date'].dt.year

# Find the sticker violation rows
sticker_violations = tickets_df[tickets_df['violation_description'].str.contains('no city sticker', case = False, na = False)]

# Look the codes inside
sticker_code = sticker_violations.groupby(['violation_code','violation_description']).size().reset_index(name = 'count')
display(sticker_code)

# Rebuild data frame for chart
sticker_code = sticker_violations.groupby(['year', 'violation_code','violation_description']).size().reset_index(name = 'count')

# Build chart and show
chart = alt.Chart(sticker_code, title = 'The Change of No City Sticker Code by Time').mark_line().encode(
    alt.X('year:O', title = 'Year'),
    alt.Color('violation_code:N', title = 'Vodlation_code'),
    alt.Y('count:Q', title = 'Number of Tickets'),
).properties(
    width = 200,  
    height = 100  
)
chart.show()
```

Thus, from the chart, we can observe that before 2012, the main "old violation code" is 0964125, while they also used 0976170. After 2012, the main "new violation code" is 0964125B, while they also used 0964125C on vehicles over 16,000 pounds.

#### 4. How much was the cost of an initial offense under each code? (You can ignore the ticket for a missing city sticker on vehicles over 16,000 pounds.)

```{python}
sticker_fines = sticker_violations[['violation_code', 'fine_level1_amount']].drop_duplicates()
display(sticker_fines)
```

If we ignore the tickets for vehicles over 16,000 pounds, which code is 0964125C, then we can find that the cost of an initial offense under each code is 120, 120, 200, reflecting that not having a required vehicle sticker rose from $120 to $200.

## Revenue increase from "missing city sticker" tickets (20 Points)

#### 1. Using pandas, create a new value for violation codes, collapse the data to capture the number of missing city sticker tickets by month. Then, using Altair, plot the number of tickets over time.

```{python}
# Create month variable 
tickets_df['year_month'] = tickets_df['issue_date'].dt.strftime('%Y-%m')

# Create a new value combing violation codes 0964125 and 0964125B, two most frenquently used codes from part 1
tickets_df['new_code'] = 0
tickets_df.loc[tickets_df['violation_code'].isin(['0964125', '0964125B']), 'new_code'] = 1

# Filter the new code = 1 to get only missing sticker tickets
sticker_violations = tickets_df[tickets_df['new_code'] == 1]

# Capture the number of missing city sticker tickets by month
sticker_code = sticker_violations.groupby("year_month").size().reset_index(name = 'monthly_tickets')

# Build chart and show
chart = alt.Chart(sticker_code, title = 'The Number of Missing City Sticker Tickets by Time').mark_line().encode(
    alt.X('yearmonth(year_month):T', title = 'Time').axis(format = '%Y'),
    alt.Y('monthly_tickets:Q', title = 'Number of Tickets Issued for No Car Sticker'),
).properties(
    width = 400,  
    height = 200  
)
chart.show()
```

#### 2. Add frequent or custom date labels on the x-axis of your plot such that the date of the price increase is readily apparent.

```{python}
# Find the no car stickter violation fines changed date
after_change = sticker_violations[sticker_violations['fine_level1_amount'] == 200]
first_day_of_price_change = after_change.loc[after_change.index[0], 'issue_date']
print(f'No car sticker violation fines changed from $120 to $200 starting at',first_day_of_price_change)

# Redraw the chart with the changed date
chart = alt.Chart(sticker_code, title = 'The Number of Missing City Sticker Tickets by Time').mark_line().encode(
    alt.X('yearmonth(year_month):T', title = 'Time').axis(format = '%Y-%m', values = ['2012-03']),
    alt.Y('monthly_tickets:Q', title = 'Number of Tickets Issued for No Car Sticker'),
).properties(
    width = 400,  
    height = 200  
)
chart.show()
```

Reference of using values from https://altair-viz.github.io/user_guide/generated/core/altair.Axis.html

#### 3. For now, ignore the fact that many tickets are not paid and assume that the number of tickets issued is the same before and after the policy change. Using only the data available in the calendar year prior to the increase, how much of a revenue increase should they have projected?

```{python}
# Calculate the number of tickets issued before policy change
before_change = sticker_violations[sticker_violations['year'] == 2011]
tickets_number_before = len(before_change)
print(f'Total number of the tickets in the year before the price increase is:', tickets_number_before)

# Calculate the revenue
stickers_revenue_before = tickets_number_before * 120
stickers_revenue_after = tickets_number_before * 200
increased_stickers_revenue = stickers_revenue_after - stickers_revenue_before
total_increased_revenue = increased_stickers_revenue * 100
print(f'They have projected revenue increase by ${total_increased_revenue:,.2f}')
```

#### 4. What happened to repayment rates (percentage of tickets issued that had payments made) on this type of ticket in the calendar year after the price increase went into effect?

```{python}
# Calculate the after change number of tickets
after_change = sticker_violations[sticker_violations['year'] == 2013]
tickets_number_after = len(after_change)
print(f'Total number of the tickets in the year after the price increase is:', tickets_number_after)

# Calculate the after change paid tickets
paid_stickers = sticker_violations[sticker_violations['ticket_queue'].str.contains('paid', case = False, na = False)]
paid_stickers_after = paid_stickers[paid_stickers['year'] == 2013]
paid_tickets_after = len(paid_stickers_after)
print(f'Total number of paid tickets in the year after the price increase is:', paid_tickets_after)

# Calculate the repayment rate after policy change
repayment_rate_after = paid_tickets_after /tickets_number_after
print(f'Repayment rate after the price increase is:', repayment_rate_after)

# Calculate the repayment rate before policy change
paid_stickers_before = paid_stickers[paid_stickers['year'] == 2011]
paid_tickets_before= len(paid_stickers_before)
print(f'Total number of paid tickets in the year before the price increase is:', paid_tickets_before)
repayment_rate_before = paid_tickets_before / tickets_number_before
print(f'Repayment rate before the price increase is:', repayment_rate_before)

# Calculate the revenue received before policy change using 2011 issued tickets number
received_revenue_before = paid_tickets_before * 120 *100
print(f'Total real world revenue received before policy change is ${received_revenue_before:,.2f}')

# Calculate the revenue received after policy change using 2011 issued tickets number as well
received_revenue_after =  tickets_number_before * 200 * repayment_rate_after * 100
print(f'Total real world revenue received after policy change is ${received_revenue_after:,.2f}')

# Calculate the projected revenue received increase after policy change
increased_received_revenue = received_revenue_after - received_revenue_before
print(f'Total projected revenue received increase by ${increased_received_revenue:,.2f}')
```

#### 5. Make a plot with the repayment rates on “missing city sticker” tickets and a vertical line at when the new policy was introduced. Interpret.

```{python}
# Use the dataframe that filtered only no city stickers violation tickets to calculate the paid violation fraction rate over month
sticker_violations['paid'] = sticker_violations['ticket_queue'].str.contains('paid', case = False, na = False).astype(int)
repayment_rate = sticker_violations.groupby('year_month').agg(
    tickets_issued = ('issue_date', 'count'),
    tickets_paid = ('paid', 'sum')
).reset_index()
repayment_rate['repayment_rate'] = repayment_rate['tickets_paid'] / repayment_rate['tickets_issued']

# Draw the line chart together with a vertical line
line_chart = alt.Chart(repayment_rate, title = 'The Repayment Rate of Missing City Sticker Tickets by Time').mark_line().encode(
    alt.X('yearmonth(year_month):T', title = 'Time').axis(format = '%Y-%m'),
    alt.Y('repayment_rate:Q', title = 'Repayment Rate'),
).properties(
    width = 400,  
    height = 200  
)

vertical_line = alt.Chart(pd.DataFrame({'date': ['2012-02-25']})).mark_rule(color='red', size = 2).encode(
    x='date:T'
)

# ref from https://github.com/vega/altair/issues/2379
# Add a text on the chart
text = alt.Chart(pd.DataFrame({'date': ['2012-02-25']})).mark_text(
    text = 'Price Increase',
    dy = -10,  # Adjust the position vertically
    color = 'red',  # Color the text to make it stand out
    fontWeight = 'bold'
).encode(
    x = 'date:T',
)

# Show the chart
combined_chart = line_chart + vertical_line + text
combined_chart.show()
```

We can observe from the graph that after the price increase, te repayment rate decreased a lot.

#### 6. What three violation types would you as an analyst have recommended they increase the price of? Consider both the number of tickets issued for each violation type and the repayment rate for each violation type. Make a plot to support your argument and explain in writing why it supports your argument.

```{python}
tickets_df['paid'] = tickets_df['ticket_queue'].str.contains('paid', case = False, na = False).astype(int)

violations = tickets_df[tickets_df['year'] == 2011]
violations = violations.groupby('violation_description').agg(
    tickets_issued = ('issue_date', 'count'),
    tickets_paid = ('paid', 'sum')
).reset_index()

# Calculate repayment rate
violations['repayment_rate'] = violations['tickets_paid'] / violations['tickets_issued']

# Find top 3 types with highest number of tickets and repayment rate
recommended_violations = violations.sort_values(by = ['tickets_issued', 'repayment_rate'], ascending = [False, False]).head(3)
recommended_violations = recommended_violations.drop(columns = 'tickets_paid')
print(recommended_violations)
violations_issued = violations.sort_values(by = ['tickets_issued'], ascending = False).head(10)
tickets_issued_chart = alt.Chart(violations_issued, title = 'Top 10 Violations').mark_bar().encode(
    alt.X('tickets_paid:Q', title = 'Number of Tickets Paid for Violations in 2011'),
    alt.Y('violation_description:N', sort = "-x", title = 'Violations types').axis(maxExtent = 200, labelLimit = 200)
).properties(
    width = 400,  
    height = 200  
)
tickets_issued_chart.show()
```

The table shows that if we rank the issued tickets first and then repayment rates, the top 3 are the same as if we rank them by paid tickets (shown in the plot). Thus, if we want to increase revenue, we need to expand the most popular violations, as people will always retake the same mistakes and are always willing to pay for these popular violations.

## Headlines and sub-messages (20 points)

#### 1. Make a data frame where each row is a violation description, the fraction of time that the ticket is paid, and the average level 1 fine. Sort this dataframe based on how many total tickets of each type have been issued. Print the rows for the 5 most common violation descriptions.

```{python}
# Group by violation_description
violations_df = tickets_df.groupby('violation_description').agg(
    tickets_issued = ('issue_date', 'count'), 
    tickets_paid = ('paid', 'sum'),  
    avg_fine = ('fine_level1_amount', 'mean')
).reset_index()

# Calculate the fraction of paid tickets
violations_df['fraction_paid'] = violations_df['tickets_paid'] / violations_df['tickets_issued']

# Sort the dataframe by the number of tickets issued
violations_df = violations_df.sort_values(by = 'tickets_issued', ascending = False)

# SUbset the top 5 most common violations
top_5_violations = violations_df.drop(columns = 'tickets_paid').head(5)
display(top_5_violations)
```

#### 2. Make a scatter plot which shows the relationship between fine amount and the fraction of tickets that are paid. Then make two other plots which show the same relationship in different ways. For all three plots, write out what are the headlines and what are sub-messages.

```{python}
# Filter out violations that appear at least 100 times
frequent_violations = violations_df[violations_df['tickets_issued'] >= 100]

# Remove the outlier with the highest average fine 
outlier = frequent_violations['avg_fine'].idxmax() 
filtered_violations = frequent_violations.drop(index = outlier)

# Create scatter plot
scatter_plot = alt.Chart(filtered_violations, title = 'Relationship Between Average Fine and Fraction of Tickets Paid').mark_point().encode(
    alt.X('avg_fine:Q', title = 'Average Fine ($)'),
    alt.Y('fraction_paid:Q', title = 'Fraction of Tickets Paid')
).properties(
    width = 200,  
    height = 200  
)

# Create a box plot
box_plot = alt.Chart(filtered_violations).mark_boxplot().encode(
    alt.X('avg_fine:Q', title = 'Average Fine ($)'),
    alt.Y('fraction_paid:Q', title = 'Fraction of Tickets Paid')
).properties(
    width = 200,  
    height = 200  
)

# Create a rect plot
rect_plot = alt.Chart(filtered_violations).mark_rect().encode(
    alt.X('avg_fine:Q', title = 'Average Fine ($)'),
    alt.Y('fraction_paid:Q', title = 'Fraction of Tickets Paid')
).properties(
    width = 200,  
    height = 200  
)

# Display the plots together
final_chart = (scatter_plot & box_plot & rect_plot)
final_chart.show()
```

1. Scatter Plot
  - Headline: 
    1. The relationship between average fine and fraction of tickets paid is downward.
  - Sub-messages:
    1. There is a noticeable cluster where lower fines tend to have a higher fraction of paid tickets, indicating that people are more willing to pay smaller fines.
    2. As the fine amount increases, the fraction of paid tickets generally decreases, showing a negative relationship between higher fines and repayment rates, especially when fine over $100.
    3. There are much less points when fines over $100 than below $100.


2. Box Plot
  - Headline: 
    1. This box plot highlights the variability of the fraction of tickets paid for each level of fine.
    2. Major distribution of repayment rates across different fine levels falls between $50 and $100.
  - Sub-messages:
    1. The plot clearly shows that for fines between $0 and $50, there is a higher median repayment rate and less variability.
    2. As the fine amount increases, the median repayment rate tends to drop, and there is more variability in how frequently tickets are paid.

3. Rect Chart
- Headline: 
    1. It highlights the decrease in repayment rate as fine Increases
  - Sub-messages:
    1. The general trend is that a higher fine leads to a decreased likelihood of payment, which becomes especially clear after a fine level of $100.
    2. This plot shows an overall trend of how average fine amounts impact repayment rates without being distracted by outliers.


#### 3. The City Clerk doesn’t understand regressions and only has time to look at one plot. Which plot are you going to bring to them and why?
I would bring them the third plot, which is the rect chart. This rect plot provides a straightforward and easy-to-understand visual representation of the relationship between the fine amount and repayment rate. Readers can clearly see the decreasing trend, and no other complex information distracts them.

## Understanding the structure of the data and summarizing it (Lecture 5, 20 Points)

#### 1. Most violation types double in price if unpaid.

```{python}
# Filter rows that do not contain the word "paid" in the 'ticket_queue' column
not_paid_df = tickets_df[~tickets_df['ticket_queue'].str.contains('paid', case=False, na=False)]
not_paid_df['doubles_in_price'] = 2 * not_paid_df['fine_level1_amount']

# Create a new column to check if 'doubles_in_price' equals 'fine_level2_amount'
not_paid_df['whether_doubles'] = not_paid_df['doubles_in_price'] == not_paid_df['fine_level2_amount']

# Group by violation description to see if all of the violations match the doubling rule
violation_summary = not_paid_df.groupby('violation_description')['whether_doubles'].all().reset_index()

# Filter violations that do not match
not_matching = violation_summary[violation_summary['whether_doubles'] == False]

not_matching_list = not_matching['violation_description'].tolist()

print(f'The following violations types do not double in price:', not_matching_list)

# Filter for rows that do not match double prices
not_paid_not_double = not_paid_df[not_paid_df['violation_description'].isin(not_matching['violation_description'])]

# Count the number of occurrences of each violation description for those that do not match the doubling rule
violation_counts = not_paid_not_double['violation_description'].value_counts()
high_citation_violations = violation_counts[violation_counts >= 100]
display(high_citation_violations)
violation_list = high_citation_violations.index.tolist()

# Filter rows in tickets_df based on the values in the violation_list
filtered_not_paid = not_paid_df[not_paid_df['violation_description'].isin(violation_list)]
filtered_not_paid['price_increased'] = filtered_not_paid['fine_level2_amount'] - filtered_not_paid['fine_level1_amount']
filtered_not_paid = filtered_not_paid.groupby(['violation_description','price_increased']).size().reset_index(name = 'count')
display(filtered_not_paid)
```

#### 2. 

```{python}
# Select the 'notice_level' and 'ticket_queue' columns
check_notice_level = tickets_df['notice_level']
clean_notice_level = check_notice_level.drop_duplicates()
display(clean_notice_level)
check_ticket_queue = tickets_df['ticket_queue']
clean_ticket_queue = check_ticket_queue.drop_duplicates()
display(clean_ticket_queue)

from IPython.display import Image
Image("notice_level.png")
```

```{python}
Image("ticket_queue.png")
```

#### 3. Implement this in two ways: (a) label every dot with adjacent text or (b) put the text in a legend.Revise the plots. First, do this the easy way, which is to pick the ten most commonly used violation descriptions and mark all the other dots as “Other”. Second, for (b), try to construct meaningful categories by marking violation descriptions which sound similar with a common label and a common color.

```{python}
# Create scatter plot and add labels for each dot
scatter_plot = alt.Chart(filtered_violations, title = 'Relationship Between Average Fine and Fraction of Tickets Paid').mark_point().encode(
    alt.X('avg_fine:Q', title = 'Average Fine ($)'),
    alt.Y('fraction_paid:Q', title = 'Fraction of Tickets Paid'),
    alt.Color('violation_description:N')
).properties(
    width = 200,  
    height = 200  
)
scatter_plot.display()

# Get the ten most common violation descriptions
filtered_violations = filtered_violations.sort_values(by = 'tickets_issued', ascending = False)
top_10_violations = filtered_violations['violation_description'].head(10).tolist()
print(top_10_violations)

# Filter rows in tickets_df based on the values in the violation_list
filtered_violations['violation_group'] = filtered_violations['violation_description'].apply(
    lambda x: x if x in top_10_violations else 'Other'
)

chart = alt.Chart(filtered_violations, title = 'Relationship Between Average Fine and Fraction of Tickets Paid').mark_point().encode(
    alt.X('avg_fine:Q', title = 'Average Fine ($)'),
    alt.Y('fraction_paid:Q', title = 'Fraction of Tickets Paid'),
    alt.Color('violation_group:N')
).properties(
    width = 200,  
    height = 200  
)
chart.display()

# Define a function to assign group labels based on keywords
def categorize_violation(description):
    if any(keyword in description.lower() for keyword in ['parking']):
        return 'Parking Related'
    elif any(keyword in description.lower() for keyword in ['expired']):
        return 'Expired Related'
    elif any(keyword in description.lower() for keyword in ['sticker']):
        return 'Sticker Related'
    elif any(keyword in description.lower() for keyword in ['tinted', 'windows']):
        return 'Window/Tinting'
    elif any(keyword in description.lower() for keyword in ['cleaning']):
        return 'Street Cleaning'
    else:
        return 'Other'

# Apply the categorization function to create a new column
filtered_violations['violation_group'] = filtered_violations['violation_description'].apply(categorize_violation)

# Plot with categorization
grouped_scatter_plot = alt.Chart(filtered_violations, title = 'Relationship Between Average Fine and Fraction of Tickets Paid').mark_point().encode(
    alt.X('avg_fine:Q', title = 'Average Fine ($)'),
    alt.Y('fraction_paid:Q', title = 'Fraction of Tickets Paid'),
    alt.Color('violation_group:N')
).properties(
    width = 200,  
    height = 200
)
grouped_scatter_plot.display()
```
